{% extends '_base.html' %}
{% load static %}

{% block title %}Playgrounds page{% endblock title %}

{% block content %}
<!-- Editor Container -->
<div class="mb-3">
  <label for="code-input" class="form-label">Write your Python code:</label>
  <textarea id="code-input">print("Hello, World!")</textarea>
</div>

<!-- Run Button -->
<button type="button" class="btn btn-success" id="run-button">Run Code</button>

<!-- Output Display -->
<pre id="output"></pre>

<!-- CodeMirror CSS -->
<link rel="stylesheet" href="https://unpkg.com/codemirror@5.65.14/lib/codemirror.css">
<link rel="stylesheet" href="https://unpkg.com/codemirror@5.65.14/theme/material.css">

<!-- CodeMirror JS -->
<script src="https://unpkg.com/codemirror@5.65.14/lib/codemirror.js"></script>
<script src="https://unpkg.com/codemirror@5.65.14/mode/python/python.js"></script>

<!-- CodeMirror Setup -->
<script>
  const editor = CodeMirror.fromTextArea(document.getElementById("code-input"), {
    mode: "python",
    theme: "material",
    lineNumbers: true,
    indentUnit: 4,
    tabSize: 4,
    indentWithTabs: false
  });

  // Optional: Set fixed editor height
  editor.setSize("100%", "400px");

  // Handle "Run Code" button
  document.getElementById("run-button").addEventListener("click", async function () {
    const code = editor.getValue();  // Use CodeMirror's value

    // Step 1: Trigger Celery task
    const response = await fetch("/playground/run_code/", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRFToken": getCSRFToken(),
      },
      body: JSON.stringify({ code: code })
    });

    const { task_id } = await response.json();
    document.getElementById("output").textContent = "Running...";

    // Step 2: Poll for task result
    const pollInterval = setInterval(async () => {
      const resultResponse = await fetch("/playground/get_result/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-CSRFToken": getCSRFToken(),
        },
        body: JSON.stringify({ task_id: task_id })
      });

      const resultData = await resultResponse.json();

      if (resultData.status === "completed") {
        clearInterval(pollInterval);
        const result = resultData.result;
        document.getElementById("output").textContent =
          "Output:\n" + result.stdout +
          "\n\nErrors:\n" + result.stderr +
          "\n\nExit Code: " + result.exit_code;
      }
    }, 1000);
  });

  // CSRF helper
  function getCSRFToken() {
    let cookieValue = null;
    const name = 'csrftoken';
    if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let cookie of cookies) {
        cookie = cookie.trim();
        if (cookie.startsWith(name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }
</script>
{% endblock content %}
